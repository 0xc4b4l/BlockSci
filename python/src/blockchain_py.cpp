//
//  blockchain_py.cpp
//  blocksci
//
//  Created by Harry Kalodner on 7/4/17.
//
//

#include "block_py.hpp"
#include "caster_py.hpp"
#include "ranges_py.hpp"
#include "range_apply_py.hpp"
#include "self_apply_py.hpp"

#include <blocksci/chain/blockchain.hpp>

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>

namespace py = pybind11;

using namespace blocksci;

void init_blockchain(py::module &m) {
    
    py::class_<DataConfiguration> (m, "DataConfiguration", "This class holds the configuration data about a blockchain instance")
    .def(py::pickle(
        [](const DataConfiguration &config) {
            return py::make_tuple(config.dataDirectory, config.errorOnReorg, config.blocksIgnored);
        },
        [](py::tuple t) {
            if (t.size() != 3) {
                throw std::runtime_error("Invalid state!");
            }
            return DataConfiguration(t[0].cast<std::string>(), t[1].cast<bool>(), t[2].cast<BlockHeight>());
        }
    ))
    ;

    py::class_<DataAccess> (m, "_DataAccess", "Private class for accessing blockchain data")
    .def("tx_with_index", [](DataAccess &access, uint32_t index) {
        return Transaction{index, access};
    }, R"docstring(
         This functions gets the transaction with given index.
         
         :param int index: The index of the transation.
         :returns: Tx
         )docstring")
    .def("tx_with_hash", [](DataAccess &access, const std::string &hash) {
        return Transaction{hash, access};
    }, R"docstring(
         This functions gets the transaction with given hash.
         
         :param string index: The hash of the transation.
         :returns: Tx
         )docstring")
    .def("address_from_index", [](DataAccess &access, uint32_t index, AddressType::Enum type) -> AnyScript {
        return Address{index, type, access}.getScript().wrapped;
    }, "Construct an address object from an address num and type")
    .def("address_from_string", [](DataAccess &access, const std::string &addressString) -> ranges::optional<AnyScript> {
        auto address = getAddressFromString(addressString, access);
        if (address) {
            return address->getScript().wrapped;
        } else {
            return ranges::nullopt;
        }
    }, "Construct an address object from an address string")
    .def("addresses_with_prefix", [](DataAccess &access, const std::string &addressPrefix) {
        py::list pyAddresses;
        auto addresses = getAddressesWithPrefix(addressPrefix, access);
        for (auto &address : addresses) {
            pyAddresses.append(address.getScript().wrapped);
        }
        return pyAddresses;
    }, "Find all addresses beginning with the given prefix")
    ;
    
    auto blockchainCl = py::class_<Blockchain>(m, "Blockchain", "Class representing the blockchain. This class is contructed by passing it a string representing a file path to your BlockSci data files generated by blocksci_parser", py::dynamic_attr());
    blockchainCl
    .def("__len__", [](Blockchain &chain) { return chain.size(); })
    .def("__bool__", [](Blockchain &range) { return !ranges::empty(range); })
    .def("__iter__", [](Blockchain &chain) { return pybind11::make_iterator(chain.begin(), chain.end()); },
         pybind11::keep_alive<0, 1>())
    .def("__getitem__", [](Blockchain &chain, int64_t posIndex) {
        auto chainSize = static_cast<int64_t>(chain.size());
        if (posIndex < 0) {
            posIndex += chainSize;
        }
        if (posIndex < 0 || posIndex >= chainSize) {
            throw pybind11::index_error();
        }
        return chain[posIndex];
    })
    .def("__getitem__", [](Blockchain &chain, pybind11::slice slice) -> ranges::any_view<decltype(chain[0]), ranges::category::random_access> {
        size_t start, stop, step, slicelength;
        if (!slice.compute(chain.size(), &start, &stop, &step, &slicelength))
            throw pybind11::error_already_set();
        
        auto blockRange = chain.blocks();
        auto subset =  ranges::view::slice(blockRange,
                                           static_cast<ranges::range_difference_type_t<decltype(blockRange)>>(start),
                                           static_cast<ranges::range_difference_type_t<decltype(blockRange)>>(stop));
        auto strided = subset | ranges::view::stride(step);
        return strided;
    })
    .def_property_readonly("all", [](Blockchain & range) {
        return pythonAllType(range.blocks());
    }, "Returns a list of all of the objects in the range")
    ;

    blockchainCl
    .def(py::init<std::string>())
    .def(py::init<DataConfiguration>())
    .def_property_readonly("config", [](Blockchain &chain) -> DataConfiguration { return chain.getAccess().config; }, "Returns the configuration settings for this blockchain")
    .def("segment", segmentChain, "Divide the blockchain into the given number of chunks with roughly the same number of transactions in each")
    .def("segment_indexes", segmentChainIndexes, "Return a list of [start, end] block height pairs representing chunks with roughly the same number of transactions in each")
    .def("address_count", &Blockchain::addressCount, "Get an upper bound of the number of address of a given type (This reflects the number of type equivlant addresses of that type).")
    .def("address_type_txes", getTransactionIncludingOutput, "Returns a list of all transactions that include outputs of the given address type")
    .def("addresses", [](Blockchain &chain, AddressType::Enum type) {
        return chain.scripts(type);
    })
    .def("blocks", [](Blockchain &chain) -> ranges::any_view<Block, ranges::category::random_access> {
        return chain.blocks();
    }, "Returns a range of all the blocks in the chain")
    .def("tx_with_index", [](Blockchain &chain, uint32_t index) {
        return Transaction{index, chain.getAccess()};
    }, R"docstring(
         This functions gets the transaction with given index.
         
         :param int index: The index of the transation.
         :returns: Tx
         )docstring")
    .def("tx_with_hash", [](Blockchain &chain, const std::string &hash) {
        return Transaction{hash, chain.getAccess()};
    }, R"docstring(
         This functions gets the transaction with given hash.
         
         :param string index: The hash of the transation.
         :returns: Tx
         )docstring")
    .def("address_from_index", [](Blockchain &chain, uint32_t index, AddressType::Enum type) -> AnyScript {
        return Address{index, type, chain.getAccess()}.getScript().wrapped;
    }, "Construct an address object from an address num and type")
    .def("address_from_string", [](Blockchain &chain, const std::string &addressString) -> ranges::optional<AnyScript> {
        auto address = getAddressFromString(addressString, chain.getAccess());
        if (address) {
            return address->getScript().wrapped;
        } else {
            return ranges::nullopt;
        }
    }, "Construct an address object from an address string")
    .def("addresses_with_prefix", [](Blockchain &chain, const std::string &addressPrefix) {
        py::list pyAddresses;
        auto addresses = getAddressesWithPrefix(addressPrefix, chain.getAccess());
        for (auto &address : addresses) {
            pyAddresses.append(address.getScript().wrapped);
        }
        return pyAddresses;
    }, "Find all addresses beginning with the given prefix")
    .def("most_valuable_addresses", mostValuableAddresses, "Get a list of the top 100 most valuable addresses")
    ;
}
